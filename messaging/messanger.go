package messaging

import (
	"bytes"
	"fmt"
	"html/template"
	"log"
	"net/smtp"
	"os"
	"strings"
	"time"
)

type SlackMessage struct {
	Blocks      []Block      `json:"blocks"`
	Text        string       `json:"text"`
	Attachments []Attachment `json:"attachments"`
}

type Block struct {
	Type     string      `json:"type"`
	Text     *TextBlock  `json:"text,omitempty"`
	Fields   []TextBlock `json:"fields,omitempty"`
	Elements []TextBlock `json:"elements,omitempty"`
}

type TextBlock struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

type Attachment struct {
	Fallback string `json:"fallback"`
	Color    string `json:"color"`
}

type Formatter struct {
	AlertLevel     string
	SeverityColors map[string]string
}

func (f *Formatter) FormatSlackMessageToSend(message, metricName, actionURL string, extraInfo map[string]string) SlackMessage {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	fallbackText := fmt.Sprintf("%s Alert: %s on %s\nMessage: %s \nTime: %s",
		strings.ToUpper(f.AlertLevel), metricName, "AgentIP", message, timestamp)

	blocks := []Block{
		{
			Type: "header",
			Text: &TextBlock{
				Type: "plain_text",
				Text: fmt.Sprintf("ðŸš¨ %s Alert", strings.Title(f.AlertLevel)),
			},
		},
		{
			Type: "section",
			Fields: []TextBlock{
				{Type: "mrkdwn", Text: fmt.Sprintf("*Timestamp:*\n%s", timestamp)},
				{Type: "mrkdwn", Text: fmt.Sprintf("*Message:*\n%s", message)},
				{Type: "mrkdwn", Text: fmt.Sprintf("*Metric:*\n%s", metricName)},
				{Type: "mrkdwn", Text: fmt.Sprintf("*Action URL:*\n%s", actionURL)},
			},
		},
	}

	if extraInfo != nil {
		var additionalFields []TextBlock
		for key, value := range extraInfo {
			additionalFields = append(additionalFields, TextBlock{
				Type: "mrkdwn",
				Text: fmt.Sprintf("*%s:*\n%s", key, value),
			})
			fallbackText += fmt.Sprintf("\n%s: %s", key, value)
		}
		if len(additionalFields) > 0 {
			blocks = append(blocks, Block{
				Type:   "section",
				Fields: additionalFields,
			})
		}
	}

	blocks = append(blocks,
		Block{Type: "divider"},
		Block{
			Type: "context",
			Elements: []TextBlock{
				{Type: "mrkdwn", Text: fmt.Sprintf("Auto-Generated By MS | Severity: %s | System: %s | Agent Version: %s", strings.Title(f.AlertLevel), "AgentIP", "AGENT_VERSION")},
			},
		},
	)

	return SlackMessage{
		Blocks: blocks,
		Text:   fallbackText,
		Attachments: []Attachment{
			{
				Fallback: fmt.Sprintf("Action Required. Immediate investigation needed %s", fallbackText),
				Color:    strings.ToUpper(f.SeverityColors[strings.ToLower(f.AlertLevel)]),
			},
		},
	}
}

func formatSlackMessageToSend(message string, metricName string, actionUrl string, extraInfo map[string]string) {

}

func formatEmailMessageData(metricName string, actionURL string, extraInfo map[string]string) {

}

// Send Email Notification
func sendEmail(to []string, subject string, body string) error {
	smtpServer := os.Getenv("EMAIL_SMTP")
	smtpPort := os.Getenv("EMAIL_PORT")
	sender := os.Getenv("EMAIL_SENDER")
	password := os.Getenv("EMAIL_PASSWORD")
	recipient := os.Getenv("EMAIL_RECIPIENT")

	senderEmail := "youremail@example.com"

	strings.EqualFold(smtpServer, "smtp.gmail.com")

	if smtpServer == "" || sender == "" || password == "" || recipient == "" {
		log.Println("Email notifications are not configured properly.")
		return fmt.Errorf("email notifications are not configured properly")
	}

	auth := smtp.PlainAuth("", sender, password, smtpServer)

	// Build the email headers and body
	msg := bytes.Buffer{}
	msg.WriteString(fmt.Sprintf("From: %s\r\n", senderEmail))
	msg.WriteString(fmt.Sprintf("To: %s\r\n", to[0])) // Sending to the first recipient (for simplicity)
	msg.WriteString(fmt.Sprintf("Subject: %s\r\n", subject))
	msg.WriteString("MIME-version: 1.0;\r\n")
	msg.WriteString("Content-Type: text/html; charset=\"UTF-8\";\r\n")
	msg.WriteString("\r\n")
	msg.WriteString(body)

	err := smtp.SendMail(smtpServer+":"+smtpPort, auth, sender, []string{recipient}, msg.Bytes())

	if err != nil {
		log.Println("Failed to send email:", err)
		return err
	} else {
		log.Println("ðŸ“§ Email alert sent successfully!")
	}

	return err
}

// Load the HTML template from file
func loadTemplate(filePath string, data []ServiceMonitorStatus) (string, error) {
	// Read the file content
	templateContent, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to read template file: %v", err)
	}

	// Parse and execute the template
	tmpl, err := template.New("emailTemplate").Parse(string(templateContent))
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %v", err)
	}

	var emailBody bytes.Buffer
	if err := tmpl.Execute(&emailBody, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	return emailBody.String(), nil
}

func alertGroups(sortedMessages []Messages) {
	// Define groups and their respective email addresses (for demo purposes)
	groupEmails := map[string][]string{
		"GroupA": {"groupa@example.com"},
		"GroupB": {"groupb@example.com"},
		"GroupC": {"groupc@example.com"},
	}

	// Loop through each group and send relevant messages
	for group, recipients := range groupEmails {
		groupMessages := filterMessagesByGroup(sortedMessages, group)
		if len(groupMessages) > 0 {
			// Load the HTML template and inject group-specific messages
			emailBody, err := loadTemplate("email_template.html", groupMessages)
			if err != nil {
				log.Printf("Error loading template for %s: %v", group, err)
				continue
			}

			// Construct the email subject
			subject := fmt.Sprintf("Alert: %d Threshold Messages for %s", len(groupMessages), group)

			// Send the email
			if err := sendEmail(recipients, subject, emailBody); err != nil {
				log.Printf("Failed to send email to %s: %v", group, err)
			} else {
				log.Printf("Alert sent to %s", group)
			}
		}
	}
}

// Filter messages by group
func filterMessagesByGroup(messages []Messages, group string) []Messages {
	var filtered []Messages
	for _, msg := range messages {
		if msg.Group == group {
			filtered = append(filtered, msg)
		}
	}
	return filtered
}
