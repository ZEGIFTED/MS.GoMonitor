package messaging

import (
	"bytes"
	"log/slog"

	//"embed"
	"html/template"

	//"bytes"
	"crypto/tls"
	"fmt"

	"github.com/ZEGIFTED/MS.GoMonitor/internal"
	"github.com/ZEGIFTED/MS.GoMonitor/pkg/constants"
	"github.com/go-mail/mail/v2"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"

	//"html/template"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

const (
	WarningAlertLevel  = "warning"
	CriticalAlertLevel = "critical"
)

// SeverityColors maps alert levels to Slack-compatible color codes.
var SeverityColors = map[string]string{
	CriticalAlertLevel: "#FF0000", // Bright Red for Critical Alerts
	"high":             "#FF4500", // Orange Red for High Alerts
	WarningAlertLevel:  "#FFA500", // Orange for Medium Alerts
	"low":              "#FFD700", // Gold for Low Alerts
	"info":             "#36A64F", // Green for Informational Messages
	"default":          "#808080", // Gray for Default/Fallback
}

func (cfgManager *NotificationManager) FormatSlackMessageToSend(event internal.ServiceAlertEvent, groupName, alertLevel, actionURL string, extraInfo map[string]string) SlackMessage {
	timestamp := time.Now().Format("2006-01-02 15:04:05")

	// Fallback text for non-rich clients
	fallbackText := fmt.Sprintf("%s Alert: %s \nMessage: %s\nTime: %s",
		strings.ToUpper(alertLevel), event.ServiceName, event.Message, timestamp)

	// Header Block
	headerBlock := slack.NewHeaderBlock(
		slack.NewTextBlockObject("plain_text", fmt.Sprintf("üö® %s Alert", strings.Title(alertLevel)), false, false),
	)

	// Section Block with main fields
	sectionFields := []*slack.TextBlockObject{
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Timestamp:*\n%s", event.Timestamp), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Message:*\n%s", event.Message), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Message Group:*\n%s", groupName), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Metric:*\n%s", event.ServiceName), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Action URL:*\n<%s|Click Here>", actionURL), false, false),
	}

	sectionBlock := slack.NewSectionBlock(nil, sectionFields, nil)

	// Add extra info if provided
	var extraInfoBlocks []slack.Block
	if len(extraInfo) > 0 {
		var extraFields []*slack.TextBlockObject
		for key, value := range extraInfo {
			extraFields = append(extraFields, slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*%s:*\n%s", key, value), false, false))
			fallbackText += fmt.Sprintf("\n%s: %s", key, value)
		}
		extraInfoBlocks = append(extraInfoBlocks, slack.NewSectionBlock(nil, extraFields, nil))
	}

	// **Action Buttons**
	buttons := slack.NewActionBlock(
		"alert_actions",
		slack.NewButtonBlockElement("acknowledge", event.ServiceName,
			slack.NewTextBlockObject("plain_text", "‚úÖ Acknowledge", false, false)).WithStyle(slack.StylePrimary),
		slack.NewButtonBlockElement("view_details", actionURL,
			slack.NewTextBlockObject("plain_text", "üîç View Details", false, false)).WithStyle(slack.StyleDefault),
	)

	// Context Block
	contextBlock := slack.NewContextBlock("", []slack.MixedElement{
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("Auto-Generated By MS | Severity: %s | System: %s | Agent Version: %s",
			strings.Title(alertLevel), event.ServiceName, "AGENT_VERSION"), false, false),
	}...)

	// Assemble all
	//blocks := append([]slack.Block{headerBlock, sectionBlock}, extraInfoBlocks...)
	//blocks = append(blocks, dividerBlock, contextBlock)

	// **Blocks Assembly**
	blocks := []slack.Block{headerBlock, sectionBlock, buttons, slack.NewDividerBlock(), contextBlock}

	alertColor, exists := SeverityColors[strings.ToLower(alertLevel)]
	if !exists {
		alertColor = SeverityColors["info"]
	}

	// Attachments for color-coded severity alerts
	attachments := []slack.Attachment{
		{
			Fallback: fallbackText,
			Color:    alertColor,
		},
	}

	return SlackMessage{
		Text:        fallbackText,
		Blocks:      blocks,
		Attachments: attachments,
	}
}

//func FormatEmailMessageToSend(event internal.ServiceAlertEvent, actionURL string, extraInfo map[string]string) string {
//	// Load the HTML template and inject event-specific messages
//	emailBody, err := loadTemplate("email_template.html", groupMessages)
//	if err != nil {
//		log.Printf("Error loading template: %v", err)
//		//continue
//	}
//
//	return emailBody
//}

// Load the HTML template from file
func loadTemplate(filePath string, data EmailTemplateData) (string, error) {
	//var emailTemplate embed.FS

	dir, _ := os.Getwd()
	//log.Println("Current working directory:", dir)

	// Read the file content
	templateContent, err := filepath.Abs(dir + "/pkg/public/" + filePath)
	if err != nil {
		return "", fmt.Errorf("failed to read template file: %v", err)
	}

	// Parse and execute the template
	tmpl, err := template.ParseFiles(templateContent)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %v", err)
	}

	var emailBody bytes.Buffer
	if err := tmpl.Execute(&emailBody, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	return emailBody.String(), nil
}

func (cfgManager *NotificationManager) FormatEmailMessageToSend(event internal.ServiceAlertEvent, userName, groupName, actionURL string, extraInfo map[string]interface{}) (string, error) {

	// Prepare template data
	data := EmailTemplateData{
		Title:       "Test Title",
		Heading:     fmt.Sprintf("The following service needs to be confirmed operational or acknowledged via the Monitoring Console: %s", event.ServiceName),
		ServiceName: event.ServiceName,
		User: UserData{
			Name:           userName,
			RecipientGroup: groupName,
		},

		ProcessTableData: event.ServiceStats,
		// Items: []string{"loop test 1", "loop test 2"},
		// "AlertLevel":  WarningAlertLevel,
		Content:     event.Message,
		ActionURL:   actionURL,
		ExtraFields: extraInfo,

		Logo: Logo{
			UseSVG: false,

			// Only used if UseSVG is false
			ImageURL: "https://www.nairaland.com/attachments/16335515_nibss_webp_webpdaf3da7d372b13f0ba3978a66d93f798",

			// SVG customization options
			Text:           "MS",
			PrimaryColor:   "#0066cc",
			SecondaryColor: "#ff9900",
		},
		Meta: MetaData{
			Timestamp:    event.Timestamp.Format("2006-01-02 15:04:05"),
			Year:         time.Now().Year(),
			CompanyName:  constants.OrganizationName,
			SupportEmail: "calebb.jnr@gmail.com",
			SupportPhone: "080X-XXX-XXXX",
			FooterLinks: []Link{
				{Text: "Privacy Policy", URL: "/privacy", NewTab: false},
				{Text: "Terms of Service", URL: "/terms", NewTab: false},
				{Text: "FAQ", URL: "/faq", NewTab: false},
			},
		},
	}

	// Load and render email template
	emailBody, err := loadTemplate("template.html", data)
	if err != nil {
		log.Printf("Error loading email template: %v", err)
		return "", fmt.Errorf("failed to load email template: %w", err)
	}

	return emailBody, nil
}

// SendEmail Notification Method
func (cfgManager *NotificationManager) SendEmail(to []string, subject string, emailBodies []string) error {
	emailConfig := cfgManager.GetEmailConfig()
	//cfgManager.Logger.Println("Email config", emailConfig)

	// Use values from cfgManager if they are not empty, otherwise fall back to constants
	smtpHost := emailConfig.SMTPServer
	if smtpHost == "" {
		smtpHost = constants.SMTPHost
	}

	smtpPort := emailConfig.SMTPPort
	if smtpPort == 0 {
		port, err := strconv.Atoi(constants.SMTPPort)
		if err != nil {
			fmt.Println("Invalid port:", constants.SMTPPort, err)
			smtpPort = 587
		}
		smtpPort = port
	}

	smtpUser := emailConfig.Username
	if smtpUser == "" {
		smtpUser = constants.SMTPUser
	}

	smtpPass := emailConfig.Password
	if smtpPass == "" {
		smtpPass = constants.SMTPPass
	}

	senderMailAddr := emailConfig.FromAddress
	if senderMailAddr == "" {
		senderMailAddr = ""
	}

	if smtpHost == "" || smtpPort == 0 || smtpUser == "" || smtpPass == "" || senderMailAddr == "" || len(to) < 1 {
		fmt.Println(smtpHost, smtpPort, senderMailAddr, smtpUser, smtpPass)
		return fmt.Errorf("email notifications are not configured properly")
	}

	d := mail.NewDialer(smtpHost, smtpPort, smtpUser, smtpPass)
	d.TLSConfig = &tls.Config{InsecureSkipVerify: false}
	d.SSL = false

	m := mail.NewMessage()
	m.SetHeader("From", senderMailAddr)
	m.SetHeader("To", to...)
	m.SetHeader("Subject", subject)

	for _, body := range emailBodies {
		m.SetBody("text/html", body)
	}

	// m.AddAlternative("text/plain", body)

	if err := d.DialAndSend(m); err != nil {
		return fmt.Errorf("failed to send email: %s", err.Error())
	}

	log.Println("üìßEmail sent successfully.")

	return nil
}

// SendReportEmail Notification Method
func (cfgManager *NotificationManager) SendReportEmail(to []string, pdfAttachmentFilePath string, csvAttachmentFilePath string) {
	emailConfig := cfgManager.GetEmailConfig()

	// Use values from cfgManager if they are not empty, otherwise fall back to constants
	smtpHost := emailConfig.SMTPServer
	if smtpHost == "" {
		smtpHost = constants.SMTPHost
	}

	smtpPort := emailConfig.SMTPPort
	if smtpPort == 0 {
		port, err := strconv.Atoi(constants.SMTPPort)
		if err != nil {
			fmt.Println("Invalid port:", constants.SMTPPort, err)
			smtpPort = 587
		}
		smtpPort = port
	}

	smtpUser := emailConfig.Username
	if smtpUser == "" {
		smtpUser = constants.SMTPUser
	}

	smtpPass := emailConfig.Password
	if smtpPass == "" {
		smtpPass = constants.SMTPPass
	}

	senderMailAddr := emailConfig.FromAddress
	if senderMailAddr == "" {
		senderMailAddr = constants.STMP_ADMIN_MAIL
	}

	if smtpHost == "" || smtpPort == 0 || smtpUser == "" || smtpPass == "" || senderMailAddr == "" || len(to) < 1 {
		fmt.Println("email notifications are not configured properly", smtpHost, smtpPort, senderMailAddr, smtpUser, smtpPass)
	}

	d := mail.NewDialer(smtpHost, smtpPort, smtpUser, smtpPass)
	d.TLSConfig = &tls.Config{InsecureSkipVerify: true}

	subject := "Hourly IT Infrastructure Report"
	body := "Please find the attached IT infrastructure report for the last hour. If you're receiving this notification, either you or a group you're part has been profiled for this notification.\n\nBest regards,\nMS Monitoring System"

	m := mail.NewMessage()
	m.SetHeader("From", senderMailAddr)
	m.SetHeader("To", to...)
	m.SetHeader("Subject", subject)
	m.SetBody("text/plain", body)
	m.Attach(pdfAttachmentFilePath)
	m.Attach(csvAttachmentFilePath)

	if err := d.DialAndSend(m); err != nil {
		slog.Error("Failed to send email.", "Error", err.Error())
	}

	log.Println("üìßEmail Report sent successfully with the report attached.")
}

// SlackBotClient creates a new SlackClient instance
func (cfgManager *NotificationManager) SlackBotClient(slackConfig_ SlackConfig) *SlackClient {
	logger := log.New(os.Stdout, "SLACK-BOT: ", log.Ldate|log.Ltime|log.Lshortfile)

	slackConfig := cfgManager.GetSlackConfig()
	cfgManager.Logger.Println("Slack config", slackConfig)

	token_, _ := os.LookupEnv("SLACK_TOKEN")

	log.Println("Slack Token >>>", slackConfig.BotToken, token_)
	token := slackConfig.BotToken
	if token == "" {

		token = token_
	}

	//signingSecret := os.Getenv("SLACK_SIGNING")
	//if signingSecret == "" {
	//	signingSecret = "love&Light"
	//}

	return &SlackClient{
		client: slack.New(token, slack.OptionDebug(true)),
		logger: logger,
	}
}

func (s *SlackClient) SendSlackMessage(channel string, message SlackMessage) (string, error) {
	s.logger.Printf("Sending to Slack Channel: %s", channel)

	msgOptions := []slack.MsgOption{
		slack.MsgOptionText(message.Text, false),
		slack.MsgOptionBlocks(message.Blocks...),
		slack.MsgOptionAttachments(message.Attachments...),
		slack.MsgOptionUsername("MS"),
		//slack.MsgOptionPostMessageParameters(params),
	}

	_, timestamp, err := s.client.PostMessage(
		// strings.ToLower(channel),
		"epayment-console",
		msgOptions...,
	)

	if err != nil {
		log.Printf("Error sending Slack alert to %s: %v", channel, err)
		return "", err
	}

	return timestamp, nil
}

// HandleMessageEvent processes incoming message events
func (s *SlackClient) HandleMessageEvent(event *slackevents.MessageEvent) {
	// Handle message event similar to Python's SimulateAIResponse
	user := event.User
	text := event.Text
	channel := event.Channel

	fmt.Printf("Message: %+v, User: %s, Text: %s, Channel: %s\n", event, user, text, channel)

	if user == "KeySupport" {
		fmt.Println(text)
	} else {
		fmt.Println(user, text)
	}
}

//func alertGroups(sortedMessages []Messages) {
//	// Define groups and their respective email addresses (for demo purposes)
//	groupEmails := map[string][]string{
//		"GroupA": {"groupa@example.com"},
//		"GroupB": {"groupb@example.com"},
//		"GroupC": {"groupc@example.com"},
//	}
//
//	// Loop through each group and send relevant messages
//	for group, recipients := range groupEmails {
//		groupMessages := filterMessagesByGroup(sortedMessages, group)
//		if len(groupMessages) > 0 {
//			// Load the HTML template and inject group-specific messages
//			emailBody, err := loadTemplate("email_template.html", groupMessages)
//			if err != nil {
//				log.Printf("Error loading template for %s: %v", group, err)
//				continue
//			}
//
//			// Send the email
//			if err := SendEmail(recipients, subject, emailBody); err != nil {
//				log.Printf("Failed to send email to %s: %v", group, err)
//			} else {
//				log.Printf("Alert sent to %s", group)
//			}
//		}
//	}
//}

// Filter messages by group
//func filterMessagesByGroup(messages []Messages, group string) []Messages {
//	var filtered []Messages
//	for _, msg := range messages {
//		if msg.Group == group {
//			filtered = append(filtered, msg)
//		}
//	}
//	return filtered
//}
