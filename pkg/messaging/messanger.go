package messaging

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"github.com/ZEGIFTED/MS.GoMonitor/monitors"
	"github.com/ZEGIFTED/MS.GoMonitor/pkg/constants"
	"github.com/go-mail/mail/v2"
	"github.com/slack-go/slack"
	"github.com/slack-go/slack/slackevents"
	"html/template"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
)

type SlackMessage struct {
	Blocks      []slack.Block      `json:"blocks"`
	Text        string             `json:"text"`
	Attachments []slack.Attachment `json:"attachments"`
}

// SlackClient handles Slack API interactions
type SlackClient struct {
	client *slack.Client
	logger *log.Logger
}

const (
	WarningAlertLevel  = "warning"
	CriticalAlertLevel = "critical"
)

// SeverityColors maps alert levels to Slack-compatible color codes.
var SeverityColors = map[string]string{
	CriticalAlertLevel: "#FF0000", // Bright Red for Critical Alerts
	"high":             "#FF4500", // Orange Red for High Alerts
	WarningAlertLevel:  "#FFA500", // Orange for Medium Alerts
	"low":              "#FFD700", // Gold for Low Alerts
	"info":             "#36A64F", // Green for Informational Messages
	"default":          "#808080", // Gray for Default/Fallback
}

func FormatSlackMessageToSend(message, metricName, alertLevel, actionURL string, extraInfo map[string]string) SlackMessage {
	timestamp := time.Now().Format("2006-01-02 15:04:05")

	// Fallback text for non-rich clients
	fallbackText := fmt.Sprintf("%s Alert: %s on %s\nMessage: %s\nTime: %s",
		strings.ToUpper(alertLevel), metricName, "AgentIP", message, timestamp)

	// Header Block
	headerBlock := slack.NewHeaderBlock(
		slack.NewTextBlockObject("plain_text", fmt.Sprintf("ðŸš¨ %s Alert", strings.Title(alertLevel)), false, false),
	)

	// Section Block with main fields
	sectionFields := []*slack.TextBlockObject{
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Timestamp:*\n%s", timestamp), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Message:*\n%s", message), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Metric:*\n%s", metricName), false, false),
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*Action URL:*\n<%s|Click Here>", actionURL), false, false),
	}

	sectionBlock := slack.NewSectionBlock(nil, sectionFields, nil)

	// Add extra info if provided
	var extraInfoFields []*slack.TextBlockObject
	if extraInfo != nil {
		for key, value := range extraInfo {
			extraInfoFields = append(extraInfoFields, slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("*%s:*\n%s", key, value), false, false))
			fallbackText += fmt.Sprintf("\n%s: %s", key, value)
		}
	}

	var extraInfoBlock slack.Block
	if len(extraInfoFields) > 0 {
		extraInfoBlock = slack.NewSectionBlock(nil, extraInfoFields, nil)
	}

	// Divider Block
	dividerBlock := slack.NewDividerBlock()

	// Context Block
	contextElements := []slack.MixedElement{
		slack.NewTextBlockObject("mrkdwn", fmt.Sprintf("Auto-Generated By MS | Severity: %s | System: %s | Agent Version: %s",
			strings.Title(alertLevel), "AgentIP", "AGENT_VERSION"), false, false),
	}
	contextBlock := slack.NewContextBlock("", contextElements...)

	// Assemble all blocks
	var blocks []slack.Block
	blocks = append(blocks, headerBlock, sectionBlock)
	if extraInfoBlock != nil {
		blocks = append(blocks, extraInfoBlock)
	}
	blocks = append(blocks, dividerBlock, contextBlock)

	alertColor, exists := SeverityColors[strings.ToLower(alertLevel)]
	if !exists {
		alertColor = SeverityColors["default"]
	}

	// Attachments for color-coded severity alerts
	attachments := []slack.Attachment{
		{
			Fallback: fallbackText,
			Color:    alertColor,
		},
	}

	return SlackMessage{
		Text:        fallbackText,
		Blocks:      blocks,
		Attachments: attachments,
	}
}

//func FormatEmailMessageToSend(metricName string, actionURL string, extraInfo map[string]string) string {
//	// Load the HTML template and inject group-specific messages
//	emailBody, err := loadTemplate("email_template.html", groupMessages)
//	if err != nil {
//		log.Printf("Error loading template: %v", err)
//		//continue
//	}
//
//	return emailBody
//}

//// SendEmail Notification Method
//func SendEmail(to []string, subject string, body string) error {
//	smtpServer := os.Getenv("MAIL_HOST")
//	smtpPort := os.Getenv("MAIL_PORT")
//	sender := os.Getenv("MAIL_USER")
//	password := os.Getenv("MAIL_PASS")
//	recipient := os.Getenv("EMAIL_RECIPIENT")
//
//	//senderEmail := "youremail@nibss-plc.com"
//
//	//strings.EqualFold(smtpServer, "smtp.gmail.com")
//
//	if smtpServer == "" || sender == "" || password == "" || recipient == "" {
//		log.Println("Email notifications are not configured properly.")
//		return fmt.Errorf("email notifications are not configured properly")
//	}
//
//	auth := smtp.PlainAuth("", sender, password, smtpServer)
//
//	// Build the email headers and body
//	msg := bytes.Buffer{}
//	//msg.WriteString(fmt.Sprintf("From: %s\r\n", sender))
//	//msg.WriteString(fmt.Sprintf("To: %s\r\n", to[0])) // Sending to the first recipient (for simplicity)
//	msg.WriteString(fmt.Sprintf("Subject: %s\r\n", subject))
//	//msg.WriteString("MIME-version: 1.0;\r\n")
//	//msg.WriteString("Content-Type: text/html; charset=\"UTF-8\";\r\n")
//	//msg.WriteString("\r\n")
//	//msg.WriteString(body)
//
//	emailBody := FormatEmailMessageToSend()
//	err := smtp.SendMail(smtpServer+":"+smtpPort, auth, sender, []string{recipient}, []byte(emailBody))
//
//	if err != nil {
//		log.Println("Failed to send email:", err)
//		return err
//	} else {
//		log.Println("ðŸ“§ Email alert sent successfully!")
//	}
//
//	return err
//}

func SendDowntimeServiceNotification(message, alertLevel, actionURL string, extraInfo map[string]string) {
}

// SendReportEmail Notification Method
func SendReportEmail(to []string, attachmentFilePath string) {
	//recipient := os.Getenv("EMAIL_RECIPIENT")

	fmt.Println(constants.SMTPHost, constants.SMTPPort, constants.SMTPUser, constants.SMTPPass)

	subject := "Hourly IT Infrastructure Report"
	body := "Please find the attached IT infrastructure report for the last hour. If you're receiving this notification, either you or a group you're part has been profiled for this notification.\n\nBest regards,\nIT Monitoring System"

	if constants.SMTPHost == "" || constants.SMTPUser == "" || constants.SMTPPass == "" || len(to) < 1 {
		log.Println("Email notifications are not configured properly.")
	}

	// Connect to the SMTP server
	port, err := strconv.Atoi(constants.SMTPPort)
	if err != nil {
		fmt.Println("Invalid port:", constants.SMTPPort, err)
		return
	}

	d := mail.NewDialer(constants.SMTPHost, port, constants.SMTPUser, constants.SMTPPass)
	d.TLSConfig = &tls.Config{InsecureSkipVerify: true}

	m := mail.NewMessage()
	m.SetHeader("From", constants.SMTPUser)
	m.SetHeader("To", to...)
	m.SetHeader("Subject", subject)
	m.SetBody("text/plain", body)
	m.Attach(attachmentFilePath)

	if err := d.DialAndSend(m); err != nil {
		log.Fatalf("Failed to send email: %s", err.Error())
	}

	log.Println("ðŸ“§Email Report sent successfully with the report attached.")

	//strings.EqualFold(smtpServer, "smtp.gmail.com")

}

// SlackBotClient creates a new SlackClient instance
func SlackBotClient() *SlackClient {
	logger := log.New(os.Stdout, "SLACK-BOT: ", log.Ldate|log.Ltime|log.Lshortfile)
	token := os.Getenv("SLACK_TOKEN")
	if token == "" {
		token = "love & Light"
	}

	signingSecret := os.Getenv("SLACK_SIGNING")
	if signingSecret == "" {
		signingSecret = "love&Light"
	}

	return &SlackClient{
		client: slack.New(token, slack.OptionDebug(true)),
		logger: logger,
	}
}

func (s *SlackClient) SendSlackMessage(channel string, message SlackMessage) (string, error) {
	s.logger.Printf("Sending to Slack Channel: %s", channel)

	msgOptions := []slack.MsgOption{
		slack.MsgOptionText(message.Text, false),
		slack.MsgOptionBlocks(message.Blocks...),
		slack.MsgOptionAttachments(message.Attachments...),
		slack.MsgOptionUsername("Monitoring Spirit"),
		//slack.MsgOptionPostMessageParameters(params),
	}

	_, timestamp, err := s.client.PostMessage(
		strings.ToLower(channel),
		msgOptions...,
	)

	if err != nil {
		log.Printf("Error sending Slack alert to %s: %v", channel, err)
		return "", err
	}

	return timestamp, nil
}

// HandleMessageEvent processes incoming message events
func (s *SlackClient) HandleMessageEvent(event *slackevents.MessageEvent) {
	// Handle message event similar to Python's SimulateAIResponse
	user := event.User
	text := event.Text
	channel := event.Channel

	fmt.Printf("Message: %+v, User: %s, Text: %s, Channel: %s\n", event, user, text, channel)

	if user == "KeySupport" {
		fmt.Println(text)
	} else {
		fmt.Println(user, text)
	}
}

// Load the HTML template from file
func loadTemplate(filePath string, data []monitors.ServiceMonitorStatus) (string, error) {
	// Read the file content
	templateContent, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("failed to read template file: %v", err)
	}

	// Parse and execute the template
	tmpl, err := template.New("emailTemplate").Parse(string(templateContent))
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %v", err)
	}

	var emailBody bytes.Buffer
	if err := tmpl.Execute(&emailBody, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	return emailBody.String(), nil
}

//func alertGroups(sortedMessages []Messages) {
//	// Define groups and their respective email addresses (for demo purposes)
//	groupEmails := map[string][]string{
//		"GroupA": {"groupa@example.com"},
//		"GroupB": {"groupb@example.com"},
//		"GroupC": {"groupc@example.com"},
//	}
//
//	// Loop through each group and send relevant messages
//	for group, recipients := range groupEmails {
//		groupMessages := filterMessagesByGroup(sortedMessages, group)
//		if len(groupMessages) > 0 {
//			// Load the HTML template and inject group-specific messages
//			emailBody, err := loadTemplate("email_template.html", groupMessages)
//			if err != nil {
//				log.Printf("Error loading template for %s: %v", group, err)
//				continue
//			}
//
//			// Send the email
//			if err := SendEmail(recipients, subject, emailBody); err != nil {
//				log.Printf("Failed to send email to %s: %v", group, err)
//			} else {
//				log.Printf("Alert sent to %s", group)
//			}
//		}
//	}
//}

// Filter messages by group
//func filterMessagesByGroup(messages []Messages, group string) []Messages {
//	var filtered []Messages
//	for _, msg := range messages {
//		if msg.Group == group {
//			filtered = append(filtered, msg)
//		}
//	}
//	return filtered
//}
